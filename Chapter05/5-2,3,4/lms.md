## 5-2 MySQL 엔진의 잠금
MySQL의 잠금은 MySQL 레벨과 스토리지 레벨로 나눌 수 있다. MySQL 레벨의 잠금은 모든 스토리지 레벨에서 적용되지만, 스토리지 엔진 레벨의 잠금은 상호 간 영향을 미치지 않는다.

### 글로벌 락
- 잠금 범위가 MySQL 서버 전체이며, MySQL에서 제공하는 잠금 중 범위가 가장 크다.
- FLUSH TABLES WITH READ LOCK 명령어로 획득할 수 있으며, 일관된 백업을 받을 때 사용된다.
- mysqldump 같은 백업 프로그램을 사용할 때는 설정에 따른 글로벌 락 동작 여부를 확인해보는 것이 좋다.
> 명령이 시작되기 전에 DDL, DML 작업을 수행하고 있다면 읽기 잠금을 걸기 위해 해당 SQL과 트랜잭션이 완료될 때 까지 기다려야 한다. 최악의 상황을 가정하면 장시간 걸리는 쿼리와 글로벌 락이 완료될 때 까지 다른 쿼리가 실행되지 못할 수도 있다.

- 일반적으로 MySQL 서버 백업은 레플리카 서버에서 실행된다. 하지만 백업이 글로벌 락을 획득하면 복제는 백업 시간만큼 지연되며, 소스 서버에 문제가 생기면 그만큼 서비스를 멈춰야 할 수도 있다.
    - XtraBackup, Enterprise Backup은 복제가 진행되는 상태에서 백업을 만들 수 있다. ( 단, 스키마 변경 시 백업 실패 )
    - 백업 락은 위와 같은 상황을 방지하기 위해 만들어졌으며, 백업 실패를 막기 위해 DDL 명령이 실행되면 복제를 중지한다.

### 테이블 락
- 개별 테이블 단위로 설정되는 잠금이며, 명시적 / 묵시적으로 특정 테이블 락을 획득할 수 있다.
- 묵시적 락은 쿼리가 실행되는 동안 자동으로 획득했다가 쿼리 완료 후 자동 해제된다.
- 모든 스토리지 엔진에 적용할 수 있으나 InnoDB 엔진의 경우 레코드 기반의 잠금을 제공하므로 스키마를 변경하는 쿼리(DDL)에만 영향을 미친다.

### 네임드 락
- 네임드 락은 테이블이나 레코드, 데이터베이스 객체가 아닌 지정 문자열에 대해 잠금을 획득한다.
- 복잡한 요건으로 레코드를 변경하는 경우, 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 데드락을 최소화할 수 있다.

### 메타데이터 락
- 데이터베이스 객체의 이름이나 구조를 변경하는 경우 자동 획득하는 잠금이다.
- 테이블 이름 변경 시 원본과 변경될 테이블 모두 잠금 설정한다. 따로 잠금 설정하고 진행할 경우 테이블이 없는 찰나의 시간이 존재하여 테이블을 못 찾는 에러가 발생된다.
- 테이블 구조 변경의 경우, 오래 걸릴 때의 언두 로그 증가와 Online DDL이 실행되는 동안 누적된 Online DDL 버퍼 등 고려해야 할 문제가 많다. MySQL 서버의 DDL은 단일 스레드로 동작하므로 pk 구간별로 나누어 진행하여 시간을 단축해야 한다. 이후 남은 데이터( 최대한 최근일수록 좋다 )는 테이블 잠금 설정하여 서비스에 미치는 영향을 최소한으로 줄일 수 있다.


## 5-3. InnoDB 스토리지 엔진
- InnoDB 스토리지 엔진은 내부에서 레코드 기반 잠금 방식을 탑재하고 있으며, 레코드 기반이기 때문에 다른 스토리지 엔진보다 동시성 처리 능력이 뛰어나다.
- 이원화된 잠금으로 인해 MySQL 명령으로 접근하기 어려웠지만, InnoDB의 중요도가 높이지면서 InnoDB 잠금에 대한 모니터링 방법도 추가됐다.

### 스토리지 엔진의 잠금
- InnoDB 스토리지 엔진은 레코드 기반 락을 제공한다.
    - <a href='http://wiki.hash.kr/index.php/%EB%A0%88%EC%BD%94%EB%93%9C'>레코드 간단 의미</a>

#### 레코드 락
- 레코드 자체만을 잠그는 것을 의미하며, 다른 DBMS와 다르게 InnoDB는 레코드 자체가 아닌 익덱스의 레코드를 잠근다.

#### 갭 락
- 레코드 자체가 아닌 레코드와 인접한 레코드 사이를 잠근다.
- 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것이다.

#### 넥스트 키 락
- 레코드 락과 갭 락을 합쳐놓은 형태이다.
- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 한다.
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.

#### 자동 증가 락
- auto_increament 컬럼을 사용하는 테이블을 위한 락
- 새로운 레코드를 생성하는 insert, replace 쿼리 문장에만 락이 걸리며, auto_increament 값을 가져오는 순간 해제된다.
- 한 번 증가된 auto_increament가 줄어들지 않는 이유는 락을 최소화하기 위함이다.

### 인덱스와 잠금
- InnoDB의 잠금은 인덱스의 레코드를 잠그는 방식이므로 명령을 수행하기 위해 관련된 모든 인덱스의 레코드를 잠금한다. 적절한 인덱스가 준비되어 있지 않다면 테이블 전체를 스캔해야 할 수도 있다. InnoDB의 설계가 중요한 이유이다.

### 레코드 수준의 잠금 확인 및 해제
- 레코드 수준의 잠금은 레코드 각각에 잠금이 걸리므로 자주 사용되지 않는 레코드라면 오랜 시간 잠겨진 상태로 남아도 발견되지 않는다.
    - 현재는 레코드 잠금과 잠금 대기에 대한 조회가 가능하다.
- 이전에는 information_schema 라는 DB에서 확인 가능했지만, 현재는 performance_schema의 테이블일 이용해 잠금 확인이 가능하다.


## 5-4 MySQL 격리 수준
- 격리수준이란 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.
- 수준이 높을수록 격리 정도가 높아지며, 동시 처리 성능도 떨어지는 것이 일반적이다.

### READ UNCOMMITTED
- 해당 경리 수준에서는 insert, update, delete 명령 후 커밋하지 않아도 다른 사용자가 결과를 조회할 수 있다.
    - 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 데이터를 확인할 수 있는 현상이 더티 리드라 한다.

### READ COMMITTED
- 해당 격리 수준에서는 트랜잭션에서 변경한 데이터가 커밋되어야 다른 트랜잭션에서 조회할 수 있다.
    - 데이터 변경 후 커밋하기 전에 다른 트랜잭션에서 데이터를 조회한다면 백업된 언두 로그의 데이터를 조회한다.
- READ COMMITTED 격리 수준은 NON-REPEATABLE READ라는 부정합 문제가 있다.
    - 사용자가 하나의 트랜잭션에서 두 번의 select 쿼리를 실행하였을 때, 그 사이 다른 트랜잭션에서 커밋이 발생한다면 다른 데이터를 조회하게 된다. REPEATABLE READ 정합성에 어긋난다.

### REPEATABLE READ
- 해당 격리 수준은 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다.
    - InnoDB 스토리지 엔진은 트랜잭션이 롤백될 가능성을 대비하여 변경되기 전 레코드를 언두 로그 공간에 백업하고 실제 레코드를 변경하며, 이러한 방식을 MVCC 라고 한다.
    - 언두 로그를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.
- InnoDB의 트랜잭션은 auto_increament로 생성되는 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다. MVCC를 보장하기 위해 실행 중인 트랜잭션의 가장 오래된 번호를 기준으로 언두 로그 영역을 제한한다.
- 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상을 PHANTOM READ라고 한다. 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없어서 발생하는 현상이다.

### SERIALIZABLE
- 다른 격리 수준과 다르게 SERIALIZABLE 격리 수준은 읽기 작업도 공유 잠금을 획득해야만 한다.
- PHANTOM READ가 발생하지 않지만 InnoDB 스토리지 엔진은 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 방지할 수 있으므로 굳이 사용할 필요성은 없다.