## 4-3 MyISAM 스토리지 엔진 아키텍쳐
- MyISAM 스토리지 엔진의 요소인 키 캐시와 운영체제의 캐시/버퍼에 대해 알아보자.

### 키 캐시
- InnoDB의 버퍼 풀 역할을 하는 것이 키 캐시 이다.
    - 메모리 역할을 한다는 의미로 생각하면 될 것 같다.
- 키 캐시는 인덱스만을 대상으로 동작하며, 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다.
- 키 캐시를 이용한 쿼리의 비율을 히트율이라고 하며, 99% 이상을 유지하는 것을 권장한다. 그렇지 않으면 키 캐시를 더 크게 설정하는 것이 좋다.
    - 운영체제에 따라 할당 가능한 메모리 제한이 있으며, 그 이상의 키 캐시를 사용하고 싶다면 별도의 캐시 공간을 설정해야 한다.
    - 별도의 키 캐시 공간은 아무런 설정을 하지 않으면 공간만 할당하고 사용하지 않게 되므로 주의해야 한다.

### 운영체제의 캐시 및 버퍼
- MyISAM 테이블의 인덱스는 키 캐시를 이용하여 디스크를 검색하지 않고도 빠르게 검색할 수 있지만, 테이블 데이터에 대해서는 디스크로부터 I/O를 해결해줄 만한 어떠한 캐시나 버퍼링도 가지고 있지 않다. ( 인덱스에 대해서만 작동하기 때문 )
    - 때문에 운영체제의 디스크 읽기, 쓰기 작업으로 요청할 수 밖에 없다. 운영체제도 디스크에 대한 캐시나 버퍼링 기능을 탑재하고 있으므로 매번 디스크에게 요청하지는 않는다.
    - MySQL이나 다른 앱에서 메모리를 모두 사용한다면 MyISAM 테이블을 캐시하지 못하여 쿼리 성능이 나빠지므로, MyISAM을 사용한다면 운영체제를 위한 충분한 메모리 공간을 확보해야 한다.

### 데이터 파일과 프라이머리 키(인덱스) 구조
- InnoDB는 pk로 클러스터링되어 저장되지만, MyISAM은 클러스터링없이 힙(heap) 공간처럼로 활용된다. 즉, pk와 무관하게 insert 순서대로 데이터 파일에 저장된다. MyISAM 테이블에 저장되는 레코드는 ROWID라는 물리적 주솟값을 가지는데, 이 값이 pk, 세컨더리 인덱스는 모두 ROWID를 포인터로 가진다.
    - 스택, 큐도 insert 순서대로 저장되는데 왜 힙 공간처럼 저장된다고 표현했을까?


## 4-4 MySQL 로그 파일
- MySQL은 많은 진단 도구들을 지원하지만, 필요 지식이 많다. 하지만 로그 파일은 깊은 지식이 없어도 부하의 원인을 쉽게 찾을 수 있다. MySQL 부하 문제에 대해서는 다른 해결 방법보다 로그 파일을 자세히 확인하는 습관을 들일 필요가 있다.

### 에러 로그 파일
- 에러 로그 파일 위치는 MySQL 설정 파일(my.cnf)에서 log_error이라는 이름의 파라미터로 정의된 경로에 생성된다.
- 설정 파일에 별도의 설정이 없는 경우 데이터 디렉터리(datadir 파라미터에 설정된 디렉터리)에 .err라는 확장자 파일로 생성된다.

### 상황별 에러 메시지
- MySQL 다시 시작하는 경우
    - MySQL 서버 정상 동작과 설저된 별수 이름이나 값이 의도한 대로 적용됐는지 확인

### 제너럴 쿼리 로그 파일
- MySQL 서버에서 실행되는 쿼리가 어떤 것들이 있는지 목록을 확인하고 싶다면 쿼리 로그를 활성화해서, 시간 단위로 기록하는 쿼리 로그 파일을 검토하면 된다.
    - 슬로우 쿼리와 다르게 쿼리 요청 시 기록하며, 실행 중 에러가 발생해도 로그 파일에 기록된다. ( general_log_file 이라는 파라미터로 설정되어 있다. )

### 슬로우 쿼리 로그
- MySQL 서버의 쿼리 튜닝은 크게 서비스 적용 전 전체적인 튜닝하는 경우와 서비스 운영 중에 전체적인 성능 저하 검사 및 정기 점검을 위한 튜닝이 있다. 전자는 모든 쿼리를 대상으로 하지만, 후자는 문제 쿼리를 판단하기 어렵다. 이 때 슬로우 쿼리 로그가 도움이 된다.
    - log_output 옵션을 통해 파일 또는 테이블로 기록할 수 있다.

- 다른 스토리지 엔진과 달리 InnoDB의 경우 MySQL 엔진 레벨과 스토리지 엔진 자체 잠금 모두 가지고 있다. 그로 인해 출력되는 슬로우 쿼리 로그에서 혼동을 유발할 수 있다.
    - 다른 스토리지 엔진에서는 테이블 단위 잠금을 사용하고, MVCC와 같은 메커니즘이 없기 때문에 select 쿼리라고 해도 lock_time이 1초 이상 소요될 가능성이 있다.
    - InnoDB의 경우에도 lock_time이 상대적으로 큰 값이 발생할 수 있는데, MySQL 엔진 레벨에서 설정한 테이블 잠금 때문일 가능성이 높다. 그래서 InnoDB 테이블에만 접근하는 슬로우 쿼리 로그의 lock_time은 쿼리 분석에 도움이 되지 않는다.

### Percona Toolkit
- 일반적으로 슬로우 로그 쿼리 또는 제너럴 로그 파일의 내용은 상당히 많아서 검토에 시간이 많이 소요된다. 이런 경우에는 Percona에서 개발한 Percona Toolkit의 pt-query-digest 스크립트를 이용하면 빈도나 쿼리 성능별로 정리하여 3그룹으로 나누어 볼 수 있다.

#### 슬로우 쿼리 통계
- 분석 결과 최상단에 표시되며, 모든 쿼리 대상으로 슬로우 쿼리 로그의 실행 시간(Exec time), 잠금 대기 시간(Lock time) 등에 대해 평균 및 최소/최대 값을 표시한다.

#### 실행 빈도 및 누적 실행 시간순 랭킹
- 각 쿼리별 응답 시간과 실행 횟수를 보여준다.
- --order-by 옵션으로 정렬 가능하다.
- Query ID는 실행된 쿼리 문장을 정규화(쿼리에 사용된 리터럴 제거)해서 만들어진 해시 값을 의미하고, 일반적으로 같은 모양의 쿼리라면 동일한 Query ID를 갖는다.
    - 리터럴이라 함은 읽기, 쓰기를 명령하는 단어 외 테이블 등을 의미하는 것인가?

#### 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보