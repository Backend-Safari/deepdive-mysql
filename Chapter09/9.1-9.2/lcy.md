# 09 옵티마이저와 힌트
- 어떤 DBMS든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡한 부분으로 알려져 있다.

## 9.1.1 쿼리 실행 절차
- MySQL 서버에서 쿼리가 실행되는 과정은 크게 세 단계로 나뉠수 있다.
    1. 사용자로부터 요청된 SQL 문장을 잘개 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
    2. SQL의 파싱 정보(파스트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
    3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
- 앞서 설명한 첫 번째 단계를 "SQL 파싱(Parsing)"이라고 하며, SQL파서 라는 모듈로 처리한다.
- MySQL 서버는 SQL 문장 그 자체가 아니라 SQL 파스 트리를 이용해 쿼리를 실행한다.
- SQL 파스트리를 참조하며 연산의 단순화, 테이블 읽는 순서 결정, 인덱스 결정, 가공해야 되는 여부 결정합니다.
- 두 번째 단계는 최적화 및 실행 계획 수립 단계이며, MySQL 서버의 "옵티마이저"에서 처리한다.
- 첫 번째 단계와 두 번째 단계는 MySQL 엔진에서 처리합니다.
- 세 번째 단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리한다.

## 9.1.2 옵티마이저의 종류
- 현재 대부분의 DBMS가 선택하고 있는 비용 기반 최적화(Cost-based optimizer, CBO), 규칙 기반 최적화 방법(Rule-based optimizer, RBO)으로 크게 나눌수 있다.


## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
- MySQL 옵티마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.
    - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
    - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
    - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- MySQL 서버에서는 innodb_read_ahead_threshold 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다.
- 리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용된다.
- 풀 테이블 스캔보다는 풀 인덱스 스캔을 하게 될 가능성이 높다.

## 9.2.3 ORDER BY 처리(Using filesort)
- 대부분 select 쿼리에서 정렬은 필수적으로 사용된다.
- 정렬은 처리하는 방법은 인덱스를 이용하는 방법과 쿼리를 실행될 때 "Filesort"라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.
- "Filesort"

## 소트 버퍼
- MySQL은 정렬은 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼(Sort buffer)라고 한다.
- 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록해 둔다.
- 병합 작업을 머리 머지(Multi-merge)라고 표현하며, 수해된 머리 머지 횟수는 Sort_merge_passes라는 상태 변수에 누적해서 집계된다.
- 트랜잭션 처리용 MySQL 서버의 소트 버퍼 크기는 56KB에서 1MB 미만이 적절해 보인다.
- 정렬을 위해 할당하는 소트 버퍼는 세션 메모리 영역에 해당한다.
- 대량의 데이터 정렬이 필요한 경우 해당 세션의 소트 버퍼만 일시적으로 늘려서 쿼리를 실행하고 다시 줄이는 것도 좋은 방법이다.


# 8.10 외래키
- TBD
