# 인덱스란
- DBMS에서 인덱스는 데이터 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
- 결국 읽기 속도와 쓰기 속도의 trade off 관계임
- 프라이머리 키: id와 같이 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
- 세컨더리 키: 프라이머리 키를 제외한 인덱스
- 유니크 인덱스: 프라이머리 키와 유사한 가능을 수행해서 대체 키라는 이름으로 불리우나, 별도로 분류하거나 세컨더리 인덱스로 분류하기도 함

## 알고리즘
- B-트리와 Hash 인덱스로 구분
- B-트리는 범용적인 인덱스 알고리즘
- Hash는 key:value 구조를 갖는 레디스와 같이 메모리 기반의 데이터베이스에서 많이 사용

## B-Tree
- Balanced Tree의 약자, 트리가 편향되어있을 경우 O(N)이므로 이를 방지하기 위해 balanced Tree를 사용
- 따라서 탐색의 시간복잡도는 O(logN)
- 바이너리 서치를 검색하면 왜 시간복잡도가 O(logN)인지 알 수 있음
- 루트노드: 최상위 노드
- 리프노드: 가장 하위의 노드
- 브랜치 노드: 중간의 노드
- DBMS에서 리프노드에는 데이터의 주소값이 저장

## 인덱스 키 추가
- 인덱스 키가 추가되는 경우 리프노드만 변경되는 것이 아니라, 상위 브랜치 노드까지 같이 수정이 일어나야 함. 최악의 경우 루트노드가 변경될 가능성이 있음
- 이는 매우 많은 디스크 접근이 일어나므로 쓰기 성능을 해칠 수 있음

## 인덱스 키 삭제 & 변경
- 해당 키 값이 저장된 리프노드를 삭제하면 됨
- 키 변경은 기존 키를 삭제한 후 새로운 키를 생성하는 방법으로 진행

## 인덱스 키 검색
- 잘 알려진 트리 탐색을 통해 검색을 수행
- 인덱스 검색은 100퍼센트 일치하거나 값의 앞부분만 일치하는 경우 사용 가능(LIKE 10*)
- 뒷부분만 검색하는 경우에는 사용 불가(LIKE *10)
  - B-Tree의 구조와 트리탐색을 생각하면 왜 안되는 지 유추할 수 있음

# B-Tree 인덱스 사용에 영향을 미치는 요소
- 인덱스 키 값의 크기
  - 키 값의 크기가 커지면 디스크 저장 용량이 증가
  - 이로 인해 디스크 접근 횟수가 많아지고, 인덱스 성능 감소
  - 그런데.. 키 값의 크기가 증가하면 장점은..?
- B-Tree 깊이
  - 인덱스 키 값에 따라 B-Tree 깊이가 결정나며, 이로 인해 성능 저하 발생 가능
- 선택도
  - 키 값 가운데 유니크한 값으 수
  - 선택도가 높을 수록(중복 값이 적을 수록) 성능이 증가
- 읽어야 하는 레코드의 건수
  - 일반적인 DBMS의 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용 발생

# B-Tree 이니덱스를 통한 데이터 읽기
- 인덱스 레인지 스캔
   1.  인덱스 탐색: 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾음
   2.  인덱스 스캔: 탐색된 위치부터 필요한 만큼 인덱스를 읽음
   3.  인덱스 스캔에서 읽어 들인 키와 레코드 주소를 이용해서 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어옴
 ... 인덱스 스캔에 대해 더 깊은 이해 필요
# 다중 칼럼 인덱스
- 다중 칼럼 인덱스에서 칼럼의 순서가 매우 중요
- 첫번째 칼럼이 먼저 정렬되고, 두번째 칼럼이 정렬되고, 그 후 세번째 칼럼이 정렬되는 순서

# B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스는 항상 오름차순 혹은 내림차순으로 정렬됨
- 차순은 인덱스를 생성할 때 설정
- 옵티마이저에 의해 첫번째부터 혹은 마지막부터 스캔 시작
- 인덱서 역순이 정순보다 더 성능이 좋지 못함
  - 이유는, 페이지 락이 인덱스 정순 스캔에 적합
  - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조이기 때문
- 데이터를 파악하고 적절히 차순을 설정해야 함

# 인덱스의 효율성 및 인덱스를 타지 않는 쿼리
- 비교조건의 종류에 의해 효율성이 달라짐
- 먼저(left-most column) =을 수행하고 나중(다음 차수의 column)에 비교(>,< 등)를 수행하는 것이 유리
- 오름차순 혹은 내림차순으로 값이 정렬되어 있기 때문에 Like %hell와 같은 쿼리는 인덱스를 타지 않음
- 또한 두번째 인덱스 컬럼에 비교 조건을 수행하는 쿼리는 인덱스를 타지 못함
  - = 연산은 탈 수 있나...?
  - 그럼 인덱스가 의미가 있나..?
  - 다중 컬럼 인덱스와 여러 컬럼에 각각 인덱스를 거는 것에 대한 리서치 필요
- 인덱스를 타지 않는 쿼리
  - NOT-Equal 비교(!= <>)
  - LIKE %whatyouwant
  - 칼럼이 변형된 후 비교되는 경우
  - 데이터 타입이 서로 다른 비교
  - 문자열 데이터 타입의 콜레이션이 다른 경우
  - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - 첫번째 컬럼의 조건이 없는 경우


