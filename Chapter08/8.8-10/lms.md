## 클러스터링 인덱스
- 여러 개를 하나로 묶는다는 클러스터링의 의미처럼, 비슷한 필드(프라이머리 키)를 기준으로 묶는 것을 의미한다.
- 프라이머리 키에 의해 저장 위치가 결정되고, 키를 변경되면 물리적인 저장 위치( 클러스터링 테이블 간 이동 )도 변경된다.
- 일반적으로 InnoDB 같이 클러스터링 인덱스로 저장되는 테이블은 조회가 빠르고, 레코드 저장 또는 프라이머리 키 수정이 상대적으로 느리다.
    - 로그 테이블과 같이 조회보다 INSERT 위주의 테이블은 auto-increment를 클러스터링 인덱스로 사용하면 성능 향상에 도움이 된다.
- B-Tree와 다르게 리프 노드에 레코드의 모든 컬럼이 저장되어 있다. 즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는 것이다.

### 프라이머리 키가 없는 InnoDB 테이블의 클러스터링 테이블은 어떻게 구성할까?
1. 프라이머리 키가 있다면 우선적으로 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 테이블 내 auto-increment 컬럼을 생성해서 클러스터링 키로 선택

InnoDB 스토리지 엔진이 후보를 찾지 못한 경우 내부적으로 레코드의 일련번호를 생성한다. 단, 아무 의미 없는 숫자로 클러스터링 되는 것이므로 프라이머리 키를 명시적으로 생성하자.

### 클러스터링 인덱스의 장단점
**장점**
- 클러스터링 키로 검색 시 성능이 매우 빠름
- 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있어서 인덱스만으로 처리되는 경우가 많음 ( 이를 커버링 인덱스라고 한다. )

**단점**
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있어 전체적으로 인덱스의 크리가 커짐
- 세컨더리 인덱스를 통한 검색 시 프라이머리 키로 다시 검색해야 하므로 처리 성능이 느림
- INSERT 시 프라이머리 키에 의해 레코드 저장 위치가 정해지므로 처리 성능이 느림
- 프라이머리 키 변경 시 레코드를 삭제 후 생성해야 하므로 처리 성능이 느림

## 유니크 인덱스
- 유니크 인덱스는 NULL도 저장 가능한데, NULL은 값이 아니므로 2개 이상 저장이 가능하다. 그러므로 MySQL에서 프라이머리 키는 기본적으로 유니크 속성을 자동 부여한다.

### 인덱스 읽기
- 유니크 인덱스와 유니크하지 않은 인덱스의 읽기 속도는 차이가 없다. 디스크가 아닌 CPU에서 컬럼을 비교하는 작업이기 때문이다.
    - 유니크 인덱스와 세컨더리 인덱스의 처리 시간 차이는 단순히 많은 건을 읽었기 때문이다.

### 인덱스 쓰기
- 새로운 인덱스가 INSERT 되거나 수정되는 경우 인덱스 쓰기 작업이 필요하다. 유니크 인덱스는 중복된 값의 검증하는 과정이 필요하므로 세컨더리 인덱스보다 처리 성능이 느리다.

## 외래키 인덱스
**InnoDB 외래키 관리 특징**
- 테이블 변경(쓰기 잠금)이 발생하는 경우 잠금 경합(잠금 대기)이 발생한다.
- 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

위 특징은 트랜잭션을 예시로 설명할 수 있다.
1. 트랜잭션 시작
2. 부모 레코드의 컬럽 업데이트
3. 자식 레코드의 외래키 수정
4. 롤백 or 커밋

위 3번 과정에서 자식 레코드의 컬럼이 외래키라면 잠금 경합이 발생하고, 그 외의 컬럼이라면 발생하지 않는다.