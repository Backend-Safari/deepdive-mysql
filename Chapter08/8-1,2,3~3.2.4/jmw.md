## 인덱스

<br>

### 랜덤 I/O와 순차 I/O

- 랜덤 I/O 표현은 하드 디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미


- 순차 I/O 또한 작업 과정은 같다.


- 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용, 풀 테이블 스캔은 순차 I/O를 사용한다.


- 순차 I/O가 랜덤 I/O보다 훨씬 빨리 많은 레코드를 읽어올 수 있기 때문이다.


<br>

### 인덱스란?

- 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어 둠


- 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.


- SortedList는 인덱스와 같은 자료 구조, ArrayList는 데이터 파일과 같은 구조


- SortedList는 이미 정렬돼 있어 아주 빨리 원하는 값을 찾아올 수 있다.


- INSERT, UPDATE DELETE 문장의 처리가 느려진다.


- 인덱스를 역할별로 구분하면 프라이머리 키와 보조키로 구분


- 프라이머리 키는 레코드를 식별할 수 있는 기준값, 식별자, NULL 값을 허용하지 않으며 중복을 허용하지 않는다.


- 데이터 저장 방식 별로 구분할 경우 대표적으로 B-Tree 와 Hash로 구분할 수 있다.


- B-Tree 인덱스는 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘


- Hash는 컬럼의 값으로 해시값을 계산해서 인덱싱, 매우 빠른 검색을 지원한다. 메모리 기반의 데이터베이스에서 많이 사용한다.

<br>

### B-Tree 인덱스

- 기본적인 구조는 최상위에 하나의 루트 노드가 존재, 그 하위에 자식 노드가 붙어 있는 형태


- 최하위에 있는 노드를 리프 노드, 중간의 노드를 브랜치 노드 라고 한다.


- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아긱 위한 주솟값을 가지고 있다.


- 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.


- MyISAM 테이블은 세턴더리 인덱스가 물리적인 주소를 가지는 반면 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다.


- InnoDB는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Trre를 다시 한번 검색해야 한다.

<br>

### 인덱스 키 추가

- MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.


- InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리 가능

<br>

### 인덱스 키 삭제

- 삭제하려는 키 값이 저장된 리프 노드를 찾아서 삭제 마크만 하면 작업 완료


- 삭제 마킹된 인덱스 키 공간은 그대로 방치 하거나 재활용할 수 있다.


- 마킹 작업 또한 디스크 쓰기가 필요함

<br>

### 인덱스 키 변경

- 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리

<br>

### 인덱스 키 검색

- 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하능 경우에 사용할 수 있다.


- InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레토드를 잠그는 방식으로 구현돼 있다.


- 따라서 UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 심지어 테이블의 모든 레코드를 잠글 수도 있다.


- InnoDB 스토리지 엔진에서는 그만큼 인덱스의 설계가 중요하다.

