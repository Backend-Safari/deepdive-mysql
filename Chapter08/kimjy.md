# 인덱스란
- DBMS에서 인덱스는 데이터 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
- 결국 읽기 속도와 쓰기 속도의 trade off 관계임
- 프라이머리 키: id와 같이 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
- 세컨더리 키: 프라이머리 키를 제외한 인덱스
- 유니크 인덱스: 프라이머리 키와 유사한 가능을 수행해서 대체 키라는 이름으로 불리우나, 별도로 분류하거나 세컨더리 인덱스로 분류하기도 함

## 알고리즘
- B-트리와 Hash 인덱스로 구분
- B-트리는 범용적인 인덱스 알고리즘
- Hash는 key:value 구조를 갖는 레디스와 같이 메모리 기반의 데이터베이스에서 많이 사용

## B-Tree
- Balanced Tree의 약자, 트리가 편향되어있을 경우 O(N)이므로 이를 방지하기 위해 balanced Tree를 사용
- 따라서 탐색의 시간복잡도는 O(logN)
- 바이너리 서치를 검색하면 왜 시간복잡도가 O(logN)인지 알 수 있음
- 루트노드: 최상위 노드
- 리프노드: 가장 하위의 노드
- 브랜치 노드: 중간의 노드
- DBMS에서 리프노드에는 데이터의 주소값이 저장

## 인덱스 키 추가
- 인덱스 키가 추가되는 경우 리프노드만 변경되는 것이 아니라, 상위 브랜치 노드까지 같이 수정이 일어나야 함. 최악의 경우 루트노드가 변경될 가능성이 있음
- 이는 매우 많은 디스크 접근이 일어나므로 쓰기 성능을 해칠 수 있음

## 인덱스 키 삭제 & 변경
- 해당 키 값이 저장된 리프노드를 삭제하면 됨
- 키 변경은 기존 키를 삭제한 후 새로운 키를 생성하는 방법으로 진행

## 인덱스 키 검색
- 잘 알려진 트리 탐색을 통해 검색을 수행
- 인덱스 검색은 100퍼센트 일치하거나 값의 앞부분만 일치하는 경우 사용 가능(LIKE 10*)
- 뒷부분만 검색하는 경우에는 사용 불가(LIKE *10)
  - B-Tree의 구조와 트리탐색을 생각하면 왜 안되는 지 유추할 수 있음